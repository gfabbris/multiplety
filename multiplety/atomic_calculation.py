import numpy as np
import os
from subprocess import call

"""
    Functions to create the inputs and run the Cowan and Racer codes.

This code needs to be in the same folder as the executables!!!!

"Results.dat" file contains the excitation energies for each symmetry (using
Butler's nomenclature! See below for more details).

The inputs contain MANY options that are now selected to generate the proper
files. See more info on the many other possible calculations with the Cowan code
on: https://www.tcd.ie/Physics/people/Cormac.McGuinness/Cowan/

The codes need to be run in order as one depends on the output of the other!!

- rcn and rcn2: calculate the atomic radial wavefunctions
- rcg: calculate the atomic energy levels and spectra
- racer: introduces the crystal field and magnetic exchange. Note that the
states are given using Butler notation (see below).
- calc_exc: organizes the excitation energies calculated by racer.
- cleanup: move all files to the selected folder.

Butler x Mulliken nomenclature

The crystal field symmetry is more often labeled using Mulliken nomenclature
(e.g. Eg, T2g), but the Racer code uses the Butler nomenclature. While the
conversion is not implemented here, the correspondence is:

Oh symmetry
Butler | Mulliken
  O    |    A1
 -O    |    A2
  1    |    T1
 -1    |    T2
  2    |    E

D4h symmetry
Butler | Mulliken
  O    |    A1
 -O    |    A2
  1    |    E
  2    |    T1
 -2    |    T2
"""

global install_folder
install_folder = '/Users/gilbertofabbris/atomic_calculation_codes/'


def edit_config(bra_config,ket_config):
    """ Input for Cowan's codes have a very specific format (it's
    fortran!), this will change the user's entries to the proper
    format.

    + Should these *_config be replaced by a list of states?

    Parameters
    -----------
    bra_config: string
        Bra state electronic configuration

    ket_config: string
        Ket state electronic configuration

    Returns
    -----------
    bra_config_out: list
        Formatted bra state electronic configuration

    ket_config_out: list
        Formatted ket state electronic configuration
    """

    bra_config_out = bra_config.upper()
    ket_config_out = ket_config.upper()

    for orbital in ['S','P','D','F','G']:
        try:
            if int(bra_config_out.split(orbital)[1].split()[0]) < 10:
                index = bra_config_out.index(orbital) + 1
                bra_config_out = bra_config_out[:index] + '0' + bra_config_out[index:]
        except IndexError:
            pass

        try:
            if int(ket_config_out.split(orbital)[1].split()[0]) < 10:
                index = ket_config_out.index(orbital) + 1
                ket_config_out = ket_config_out[:index] + '0' + ket_config_out[index:]
        except IndexError:
            pass

    return bra_config_out,ket_config_out

def rcn(atomic_number, atom_label, bra_config, ket_config):
    """ Creates input and runs the programs rcn and rcn2

    Parameters
    -----------
    atomic_number: int
        Atomic number

    atom_label: string
        Label for this ion (usually I use the atom plus its valence,
    for instance: Ni2+)

    bra_config: string
        Bra state electronic configuration

    ket_config: string
        Ket state electronic configuration

    Returns
    -----------
    None

    Files
    -----------
    rcn31_in.dat:
        Input file for rcn.

    rcn31_out.dat:
        Output file for rcn.

    FTN02:
        Binary file used by rcn2.
    """

    print('\nStarting RCN ...', end=' ')

    current_folder = os.getcwd()
    os.chdir(install_folder)

    in36 = open('fort.10', 'w')

    bra_config, ket_config = edit_config(bra_config, ket_config)

    for i in range(4 - len(atom_label)):
        atom_label = ' ' + atom_label

    in36.write('200-90 0 2  010    1      5e-8     1e-11-2 00199 0    1 0.65    0    1   -6\n')
    in36.write('   {:d}     {:s} {:s}         {:s}\n'.format(atomic_number, atom_label, bra_config, bra_config))
    in36.write('   {:d}     {:s} {:s}         {:s}\n'.format(atomic_number, atom_label, ket_config, ket_config))
    in36.write('   -1\n')
    in36.close()


    if call('./rcn31', shell = True) != 0:
        print('Failed to run RCN31!!!')
        return
    else:
        call('cp fort.10 rcn31_in.dat', shell = True)
        call('cp fort.9 rcn31_out.dat', shell = True)
        print('Done!')

    os.chdir(current_folder)

def rcn2():
    """ Creates input and runs the rcn2 program.

    Parameters
    -----------
    None

    Returns
    -----------
    None

    Files
    -----------
    FTN02:
        Input that was generated by rcn.

    rcn2_in.dat:
        Input file for rcn2.

    rcn2_out.dat:
        Output file for rcn2.

    fort.11:
        Output generated to be the input of rcg program.
    """

    print('Starting RCN2 ... ', end=' ')

    current_folder = os.getcwd()
    os.chdir(install_folder)

    in2 = open('fort.10', 'w')
    in2.write('G5INP     000                 00        00000000  9999999999 .00       1229\n')
    in2.write('        -1\n')
    in2.close()

    if call('./rcn2', shell = True) != 0:
        print('Failed to run RCN2!!!')
        return
    else:
        call('cp fort.10 rcn2_in.dat', shell = True)
        call('cp fort.9 rcn2_out.dat', shell = True)
        print('Done!')

    os.chdir(current_folder)

def slater_check(bra_config,ket_config):
    """  Figure out how many of each slater integrals and spin-orbit terms
    are needed.

    Parameters
    -----------
    bra_config: string
        Bra state configuration

    ket_config: string
        Ket state configuration

    Returns
    -----------
    slater: list
        Contains [#Fii core, #Fii valence, #Fij, #Gij]
    so: 2d list
        so[i][j] = 0,1 if spin orbit needs to be applied to each orbital (i)
        of the ground/excited (j=0/1) state.

    """

    slater = []
    ls = []
    so = []
    for states in (bra_config.split(), ket_config.split()):
        slater.append([])
        ls.append([])
        so.append([])
        for level in states:
            so[-1].append(1)
            if 'S' in level:
                slater[-1].append(0)
                ls[-1].append(0)
                so[-1][-1] = 0

            if 'P' in level:
                if int(level[2:]) not in (0,1,5,6):
                    slater[-1].append(1)
                    ls[-1].append(1)
                else:
                    slater[-1].append(0)
                    if int(level[2:]) in (0,6):
                        ls[-1].append(0)
                        so[-1][-1] = 0
                    else:
                        ls[-1].append(1)

            if 'D' in level:
                if int(level[2:]) not in (0,1,9,10):
                    slater[-1].append(2)
                    ls[-1].append(2)
                else:
                    slater[-1].append(0)
                    if int(level[2:]) in (0,10):
                        ls[-1].append(0)
                        so[-1][-1] = 0
                    else:
                        ls[-1].append(2)

            if 'F' in level:
                if int(level[2:]) not in (0,1,13,14):
                    slater[-1].append(3)
                    ls[-1].append(3)
                else:
                    slater[-1].append(0)
                    if int(level[2:]) in (0,14):
                        ls[-1].append(0)
                        so[-1][-1] = 0
                    else:
                        ls[-1].append(3)

    for i in range(len(ls)):
        if 0 not in (ls[i][:]):
            slater[i].append(min(ls[i]))
            slater[i].append((sum(ls[i]) + 1)/2)
        else:
            slater[i].append(0)
            slater[i].append(0)

    return slater,so

def rcg(bra_config,ket_config,crystal_field,symmetry,magnetic,fdd,fpd,gpd,
        coreso,valso):

    """  Creates input and runs the rcg program.
    + This function assumes that there is only 1 unfilled shell in the
    ground state!!
    + This needs to be revised if you'll use F electrons!!!!
    + Is there a better way to organize the states to calculate?

    Parameters
    -----------

    bra_config: string
        Bra state configuration.

    ket_config: string
        Ket state configuration.

    crystal_field: boolean
        Determines if crystal field will be used.

    symmetry: string
        Contains the symmetry of the crystal field to be applied.

    magnetic: boolean
        Determines if magnetic exchange will be used.

    fdd: int
        Reduction of the atomic Fdd slater integral in percent.

    fpd: int
        Reduction of the atomic Fpd slater integral in percent.

    Gpd: int
        Reduction of the atomic Gpd slater integral in percent.

    coreso: int
        Reduction of the atomic core spin orbit coupling in percent.

    valso: int
        Reduction of the atomic core spin orbit coupling in percent.

    Returns
    -----------
    None

    Files
    -----------
    fort.11:
        Input that was generated by rcn that serves as template.

    rcg_in.dat:
        Input file for rcn2.

    rcg_out.dat:
        Output file for rcn2.

    fort.14:
        Output generated to be used by the racer program.
    """

    current_folder = os.getcwd()
    os.chdir(install_folder)

    print('Starting RCG ... ', end=' ')

    ing11 = open('fort.10', 'w')
    f11 = open('fort.11', 'r').readlines()

    bra_config, ket_config = edit_config(bra_config, ket_config)

    #Start writing the rcg input
    if 'Oh' in symmetry:
        ing11.write('   10    1    0   14    4    4    1    1 ')
    else:
        ing11.write('   10    1    0   14    2    4    1    1 ')

    # This determines the state where CEF and magnetic exchange will be
    #applied to. It assumes that there is only one unfilled shell in the
    #ground state!
    if crystal_field == True:
        if 'F' in bra_config:
            ing11.write('SHELL30000000 ')
        else:
            ing11.write('SHELL03000000 ')

    if magnetic == True:
        if 'F' in bra_config:
            ing11.write('SPIN30000000 ')
        else:
            ing11.write('SPIN03000000 ')

    ing11.write('INTER8\n')

    ing11.write('    0                         {:2d}99{:2d}{:2d}            8065.47800     0000000\n'.format(fdd,fpd,gpd))

    ing11.write(f11[2])

    if 'F' in bra_config:
        states = f11[3].split('\n')[0].split('  ')
        tmp = states[0]

        for st in states:
            if 'F' in st:
                ind = states.index(st)
                states[0] = st
                states[ind] = tmp
        #print states
        ing11.write(states[0])
        for st in states[1:]:
            ing11.write('  ' + st)

        ing11.write('\n')
    else:
        ing11.write(f11[3])

    if 'F' in ket_config:
        states = f11[4].split('\n')[0].split('  ')
        tmp = states[0]
        for st in states:
            if 'F' in st:
                ind = states.index(st)
                states[0] = st
                states[ind] = tmp

        ing11.write(states[0])
        for st in states[1:]:
            ing11.write('  ' + st)

        ing11.write('\n')
    else:
        ing11.write(f11[4])

    slater, so = slater_check(bra_config,ket_config)

    # Organizing Fii, SO, Fij and Gij!
    nline = 0
    counter = 0
    for line in f11[5:]:
        if ('HR9999' in line) & (counter < 2):
            counter += 1

            nline = f11[f11.index(line) + 1]
            line = line[:20] + '    0.0000' + line[30:]

            if bra_config in line:
                i = 0
            else:
                i = 1

            param = line.split('HR99')[0].split()[-4:]

            if (sum(slater[i]) + sum(so[i])) > 4:
                for p in nline.split():
                    param.append(p)
                    nline = -1e5

            #print param

            if so[i][0] == 1:
                param[sum(slater[i][0:2])] = '{:0.4f}'.format(float(param[sum(slater[i][0:2])])*coreso/100.)

            for j in range(len(so[i])-1):
                param[sum(slater[i][0:2]) + so[i][0] + j] = '{:0.4f}'.format(float(param[sum(slater[i][0:2]) + so[i][0] + j])*valso/100.)
                #print 'SO = ' + param[sum(slater[i][0:2]) + so[i][0] + j]

            #print param

            if ('F' in bra_config) & (sum(so[i]) > 1):
                tmp = param[sum(slater[i][0:2])]
                param[sum(slater[i][0:2])] = param[sum(slater[i][0:2]) + sum(so[i]) - 1]
                param[sum(slater[i][0:2]) + sum(so[i]) - 1] = tmp

            ing11.write(line[:30])

            for p in param[:4]:
                for i in range(5 - len(p.split('.')[0])):
                    ing11.write(' ')
                ing11.write(p)

            ing11.write('HR99999999\n')

            if len(param) > 4:
                for p in param[4:]:
                    for i in range(5 - len(p.split('.')[0])):
                        ing11.write(' ')
                    ing11.write(p)

                ing11.write('\n')

        elif nline != -1e5:
            ing11.write(line)

        else:
            nline = 0

    ing11.close()


    if call('./rcg', shell = True) != 0:
        print('Failed to run RCG!!!')
        return
    else:
        call('cp fort.10 rcg_in.dat', shell = True)
        call('cp fort.9 rcg_out.dat', shell = True)
        call('cp fort.14 rcg_rme.dat', shell = True)
        print('Done!')

    os.chdir(current_folder)

def racer(bra_config,ket_config,crystal_field,symmetry,dq10,d1,d3,
          magnetic,mag_energy,verbose = False):

    """  Creates input and runs the racer program.
    + Check if used for F states!!!!!!!!

    Parameters
    -----------

    bra_config: string
        Bra state configuration.

    ket_config: string
        Ket state configuration.

    crystal_field: boolean
        Determines if crystal field will be used.

    symmetry: string
        Contains the symmetry of the crystal field to be applied (in eV).

    dq10: float
        Crystal field 10Dq energy.

    d1: float
        Difference in energy between yz/zx and xy d orbitals (in eV).

    d3: float
        Difference in energy between 3z2-r2 and x2-y2 d orbitals (in eV).

    magnetic: boolean
        Determines if magnetic exchange will be used.

    mag_energy: float
        Magnetic exchange energy (in eV).

    verbose: boolean
        Will print the crystal field energies if true.

    Returns
    -----------
    None

    Files
    -----------
    fort.14:
        Input that was generated by rcg.

    racer_in.rac:
        Input file for racer.

    racer_out.ora:
        Output file for racer.
    """

    current_folder = os.getcwd()
    os.chdir(install_folder)

    print('Starting RACER ...', end=' ')

    inracer = open('racer_in.rac', 'w')

    #Racer takes in the X400, 420, 220 crystal field parameters!
    dt = (3.0*d3 - 4.0*d1)/35
    ds = (d3 + d1)/7.0
    dq = dq10/10.0

    x400 = np.sqrt(30)*(6*dq - 3.5*dt)
    x420 = -2.5*np.sqrt(42)*dt
    x220 = -np.sqrt(70)*ds

    if verbose == True:
        print('\n')
        print('Crystal field energies')
        print('X400: ' + str(x400))
        print('X420: ' + str(x420))
        print('X220: ' + str(x220))

        print('10dq: ' + str(10*dq))
        print('dt: ' + str(dt))
        print('ds: ' + str(ds))
        print('\n')


    if symmetry == 'Oh':

        if d1 or d3 != 0.0:
            print('\nWARNING! Delta 1 and/or Delta 3 must be zero in Oh symmetry!!')
            print('Forcing d1 and d3 = 0.0!')
            x400 = np.sqrt(30)*6*dq

        if magnetic == True:
            print("\nWARNING! Only C4h symmetry can be used for magnetic calculations!")
            print("This calculation will be non-magnetic!")

        inracer.write('Y\n')
        inracer.write('BUTLER O3\n')
        inracer.write('TO OH\n')
        inracer.write('ENDCHAIN\n')
        inracer.write('\n')

        inracer.write('ACTOR 0+ HAMILTONIAN GROUND PRINTEIG\n')
        inracer.write('  OPER HAMILTONIAN\n')
        inracer.write('    BRANCH 0+ > 0 0+   1.00\n')
        if crystal_field == True:
            if 'F' in bra_config:
                inracer.write('  OPER SHELL1\n')
            else:
                inracer.write('  OPER SHELL2\n')
            inracer.write('    BRANCH 4+ > 0 0+   {:0.5f}\n'.format(x400))
        inracer.write('\n')

        inracer.write('ACTOR 0+ HAMILTONIAN EXCITE PRINTEIG\n')
        inracer.write('  OPER HAMILTONIAN\n')
        inracer.write('    BRANCH 0+ > 0 0+   1.00\n')
        if crystal_field == True:
            if 'F' in ket_config:
                inracer.write('  OPER SHELL1\n')
            else:
                inracer.write('  OPER SHELL2\n')
            inracer.write('    BRANCH 4+ > 0 0+   {:0.5f}\n'.format(x400))
        inracer.write('\n')

        inracer.write('ACTOR 1- LEFT        TRANSI PRINTTRANS 050\n')
        inracer.write('  OPER MULTIPOLE\n')
        inracer.write('    BRANCH 1- > 0 1-   1.00\n')


    if symmetry == 'D4h':

        if magnetic == True:
            print("\nWARNING! Only C4h symmetry can be used for magnetic calculations!")
            print("This calculation will be non-magnetic!")

        inracer.write('Y\n')
        inracer.write('BUTLER O3\n')
        inracer.write('TO OH\n')
        inracer.write('TO D4H\n')
        inracer.write('ENDCHAIN\n')
        inracer.write('\n')

        inracer.write('ACTOR 0+ HAMILTONIAN GROUND PRINTEIG\n')
        inracer.write('  OPER HAMILTONIAN\n')
        inracer.write('    BRANCH 0+ > 0 0+ > 0+   1.00\n')
        if crystal_field == True:
            inracer.write('  OPER SHELL2\n')
            inracer.write('    BRANCH 4+ > 0 0+ > 0+ {:0.5f}\n'.format(x400))
            inracer.write('    BRANCH 4+ > 0 2+ > 0+ {:0.5f}\n'.format(x420))
            inracer.write('    BRANCH 2+ > 0 2+ > 0+ {:0.5f}\n'.format(x220))

        inracer.write('ACTOR 0+ HAMILTONIAN EXCITE PRINTEIG\n')
        inracer.write('  OPER HAMILTONIAN\n')
        inracer.write('    BRANCH 0+ > 0 0+ > 0+   1.00\n')
        if crystal_field == True:
            inracer.write('  OPER SHELL2\n')
            inracer.write('    BRANCH 4+ > 0 0+ > 0+ {:0.5f}\n'.format(x400))
            inracer.write('    BRANCH 4+ > 0 2+ > 0+ {:0.5f}\n'.format(x420))
            inracer.write('    BRANCH 2+ > 0 2+ > 0+ {:0.5f}\n'.format(x220))
            inracer.write('\n')

        inracer.write('ACTOR  1- LEFT        TRANSI PRINTTRANS 050\n')
        inracer.write('  OPER MULTIPOLE\n')
        inracer.write('    BRANCH 1- > 0 1- >  1-  1.00\n\n')

        inracer.write('ACTOR ^0- PARALLEL    TRANSI PRINTTRANS 050\n')
        inracer.write('  OPER MULTIPOLE\n')
        inracer.write('    BRANCH 1- > 0 1- > ^0-  1.00\n')

        inracer.write('\n')

    if symmetry == 'C4h':

        inracer.write('Y\n')
        inracer.write('BUTLER O3\n')
        inracer.write('TO OH\n')
        inracer.write('TO D4H\n')
        inracer.write('TO C4H\n')
        inracer.write('ENDCHAIN\n')
        inracer.write('\n')

        inracer.write('ACTOR 0+ HAMILTONIAN GROUND PRINTEIG\n')
        inracer.write('  OPER HAMILTONIAN\n')
        inracer.write('    BRANCH 0+ > 0 0+ > 0+ > 0+   1.00\n')
        if crystal_field == True:
            if 'F' in bra_config:
                inracer.write('  OPER SHELL1\n')
            else:
                inracer.write('  OPER SHELL2\n')
            inracer.write('    BRANCH 4+ > 0 0+ > 0+ > 0+ {:0.5f}\n'.format(x400))
            inracer.write('    BRANCH 4+ > 0 2+ > 0+ > 0+ {:0.5f}\n'.format(x420))
            inracer.write('    BRANCH 2+ > 0 2+ > 0+ > 0+ {:0.5f}\n'.format(x220))
        if magnetic == True:
            inracer.write('  OPER SPIN2\n')
            inracer.write('    BRANCH 1+ > 0 1+ > ^0+ > 0+ {:0.5f}\n'.format(mag_energy))
        inracer.write('\n')

        inracer.write('ACTOR 0+ HAMILTONIAN EXCITE PRINTEIG\n')
        inracer.write('  OPER HAMILTONIAN\n')
        inracer.write('    BRANCH 0+ > 0 0+ > 0+ > 0+   1.00\n')
        if crystal_field == True:
            if 'F' in ket_config:
                inracer.write('  OPER SHELL1\n')
            else:
                inracer.write('  OPER SHELL2\n')
            inracer.write('    BRANCH 4+ > 0 0+ > 0+ > 0+ {:0.5f}\n'.format(x400))
            inracer.write('    BRANCH 4+ > 0 2+ > 0+ > 0+ {:0.5f}\n'.format(x420))
            inracer.write('    BRANCH 2+ > 0 2+ > 0+ > 0+ {:0.5f}\n'.format(x220))
        if magnetic == True:
            inracer.write('  OPER SPIN2\n')
            inracer.write('    BRANCH 1+ > 0 1+ > ^0+ > 0+ {:0.5f}\n'.format(mag_energy))
        inracer.write('\n')

        inracer.write('ACTOR  1- LEFT        TRANSI PRINTTRANS 050\n')
        inracer.write('  OPER MULTIPOLE\n')
        inracer.write('    BRANCH 1- > 0 1- >  1- >  1-  1.00\n\n')

        inracer.write('ACTOR -1- RIGHT       TRANSI PRINTTRANS 050\n')
        inracer.write('  OPER MULTIPOLE\n')
        inracer.write('    BRANCH 1- > 0 1- >  1- > -1-  1.00\n\n')

        inracer.write('ACTOR  0- PARALLEL    TRANSI PRINTTRANS 050\n')
        inracer.write('  OPER MULTIPOLE\n')
        inracer.write('    BRANCH 1- > 0 1- > ^0- >  0-  1.00\n\n')
    inracer.close()


    if call('./racer fort.14 racer_out.ora < racer_in.rac', shell = True) != 0:
        print('Failed to run RACER!!!')
        return
    else:
        print('Done!')

    os.chdir(current_folder)

def atomic_calculation_summary(atom_label,ket_config,crystal_field,symmetry,
                               dq10,d1,d3,magnetic,mag_energy,verbose=False):
    """ Reads the output of racer and sumarizes the results in the resuts.dat
    file.

    Parameters
    -----------

    atom_label: string
        Label used of the atom and valence state.

    ket_config: string
        Ket state configuration.

    crystal_field: boolean
        Determines if crystal field will be used.

    symmetry: string
        Contains the symmetry of the crystal field to be applied (in eV).

    dq10: float
        Crystal field 10Dq energy.

    d1: float
        Difference in energy between yz/zx and xy d orbitals (in eV).

    d3: float
        Difference in energy between 3z2-r2 and x2-y2 d orbitals (in eV).

    magnetic: boolean
        Determines if magnetic exchange will be used.

    mag_energy: float
        Magnetic exchange energy (in eV).

    verbose: boolean
        Will print the crystal field energies if true.

    Returns
    -----------
    None

    Files
    -----------
    racer_out.ora:
        Input file, generated by racer.

    results.dat:
        Contains the calculated crystal field states energies.
    """

    current_folder = os.getcwd()
    os.chdir(install_folder)

    print('Generating calculations results ... ', end=' ')

    content = open('racer_out.ora','r').readlines()

    states = []
    labels = []
    check_old = 0
    check = 0

    #The energies are saved in to "states", and the corresponding label in "labels"
    try:
        ind = content.index(' CALCULATIONS for ACTOR: HAMILTONIAN EXCITE\n')
        for line in content[ind+1:]:
            if 'EIGENVALUES' in line:
                check = check_old + 1

            if 'TRIAD' in line:
                labels.append(line.split()[6])

            if 'EIGVAL' in line:
                tmp = line.split('VAL',1)[1].split()
                for i in range(len(tmp)):
                    tmp[i] = float(tmp[i])
                if check != check_old:
                    states.append(tmp)
                    check_old = check
                else:
                    for i in range(len(tmp)):
                        states[check-1].append(float(tmp[i]))


            if 'ACTOR' in line:
                break
    except ValueError:
        print('Could not find ground state calculation!')

    output = open('results.dat','w')

    output.write(atom_label + ' ' + ket_config + '\n\n')

    if crystal_field == True:
        output.write('{:s} crystal field symmetry\n'.format(symmetry))
        output.write('10dq = {:0.3f} eV\n'.format(dq10))
        if symmetry != 'Oh':
            output.write('Delta 1 = {:0.3f} eV\n'.format(d1))
            output.write('Delta 3 = {:0.3f} eV\n'.format(d3))

    if magnetic == True and symmetry != 'Oh':
        output.write('Magnetic calculation\n')
        output.write('M = {:0.3f} eV\n'.format(mag_energy))

    output.write('\nStates absolute energy (eV)\n')
    if verbose == True:
        print('\n\nStates absolute energy (eV)\n')

    for i in range(len(states)):
        if verbose == True:
            print(labels[i], ' ')
        output.write(labels[i])
        for j in states[i][:]:
            if verbose == True:
                print(' {:0.3f}'.format(j), ' ')
            output.write(' {:0.3f}'.format(j))
        if verbose == True:
            print('')
            output.write('\n')

    if verbose == True:
        print('')
    output.write('\n')

    gs_local = 1E10
    for line in states:
        if gs_local > np.min(line):
            gs_local = np.min(line)

    excit = []
    label = []

    #excit and label are used to sort the excited states by energy
    for i in range(len(states)):
        for j in range(len(states[i])):
            excit.append(states[i][j])
            label.append(labels[i])

    excit, label = (list(x) for x in zip(*sorted(zip(excit, label))))

    if verbose == True:
        print('Ground state energy = {:0.4f}eV'.format(gs_local))
        print('Symmetry  Energy(eV)\n')
    output.write('Ground state energy = {:0.4f} eV\n\n'.format(gs_local))
    output.write('Symmetry  Energy(eV)\n')

    for i in range(len(label)):
        if verbose == True:
            print(label[i], excit[i])
        output.write('   {:s}       {:0.4f}\n'.format(label[i],excit[i] - gs_local))

    output.close()

    print('Done!')

    os.chdir(current_folder)


def save_atomic_calculation(save_folder,rixs_calculation = False,
                            file_label = ''):
    """ Moves all files to the save folder

    Parameters
    -----------
    save_folder: string
        Folder where files will be saved.

    rixs_calculation: boolean
        If true it will add the file_label to the files.

    file_label: string
        Will be added to the beginning of each file.

    Returns
    -----------
    None

    """

    current_folder = os.getcwd()
    os.chdir(install_folder)

    save_folder = current_folder + '/' + save_folder

    print('Saving files in calculation folder ...')

    files = ['rcn31_in.dat',
             'rcn31_out.dat',
             'rcn2_in.dat',
             'rcn2_out.dat',
             'rcg_in.dat',
             'rcg_out.dat',
             'rcg_rme.dat',
             'racer_in.rac',
             'racer_out.ora',
             'results.dat']


    #Checking if the calculation folder exists. If there is files in it, it will
    #be saved to calc_folder/old#, where # is the first available number.

    if os.path.isdir(save_folder) is True:
        print("WARNING!\n{:s} already exists!!".format(save_folder))

        files_in = os.listdir(save_folder)

        for line in files_in:
            if 'old' or '.DS_Store' in line:
                files_in.remove(line)

        if files_in == []:
            print("{:s} is empty.".format(save_folder))

        elif file_label != 'emi_':
            print("{:s} is not empty.".format(save_folder))
            for fnum in range (21):
                new_folder = save_folder[:-1] + '/old' + str(fnum) + '/'
                if os.path.isdir(new_folder) is False:
                    break

            #os.mkdir(new_folder)
            call('mkdir -p {}'.format(new_folder), shell = True)

            if fnum == 20:
                print('There are more than 20 \old folders!')

            if call('cp ' + save_folder + '*.* ' + new_folder, shell = True) == 0:
                print('Old files copied to {:s}'.format(new_folder))
            else:
                print("Could't copy old files.")

    else:
        #os.mkdir(self.calc_folder)
        call('mkdir -p {}'.format(save_folder), shell = True)

    for fname in files:
        if rixs_calculation is False:
            check = call('mv '+ fname + ' "' + save_folder + '"', shell = True)
        else:
            check = call('mv '+ fname + ' "' + save_folder + file_label + fname + '"', shell = True)

        if check != 0:
            print(("Could't move file {:s}".format(fname)))
            if call('cp ' + fname + ' "' + save_folder + file_label + fname + '"', shell = True) != 0:
                print("Couldn't copy {:s} from calculation folder!!!".format(fname))

    frem = ['fort.9',
            'fort.10',
            'fort.11',
            'fort.14',
            'FTN02']

    for f in frem:
        call('rm {:s}'.format(f), shell = True)

    print('Results at {:s}results.dat'.format(save_folder + file_label))
    print('Done!')

    os.chdir(current_folder)
